<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>객체지향언어 - 클래스와 객체</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <style>
    .md-container {
      width : min(775px, 90vw);
      margin :auto;
    }

    pre {
      border: 0.5px solid lightgray;
      background-color:  #f7f7f7;
      margin-top : 30px;
      margin-bottom : 30px;
    }

    img {
      width: 100%;
      margin-top : 25px;
      margin-bottom : 25px;
    }

    h2 {
      margin-top : 40px;
      margin-bottom : 40px;
    }

    h3 {
      margin-top : 40px;
      margin-bottom : 40px;
    }
    h4 {
      margin-top : 40px;
      margin-bottom : 40px;
    }
    h5 {
      margin-top : 40px;
      margin-bottom : 40px;
    }

  </style>
</head>
<body>
  <div class="md-container">
    <h2 id="-">객체지향언어</h2>
<h3 id="-">객체지향언어란 ?</h3>
<ul>
<li><p>컴퓨터 프로그램의 명령어 목록으로 보는 시각에서 벗어나 실제 사물을 빗댄 여러 개의 독립된 단위 &#39;객체&#39;들의 모임으로 파악하고자 하는 것</p>
</li>
<li><p>코드 간의 서로 관계를 맺어 줌으로써 보다 유기적으로 프로그램을 구성하는 것</p>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-number">1</span>. 코드의 재사용성이 좋다.
새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
<span class="hljs-number">2</span>. 코드의 관리가 용이하다.
코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
<span class="hljs-number">3</span>. 신뢰성이 높은 프로그래밍을 가능하게 한다.
제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드를 불일치로 인한 오동작을 방지할 수 있다.
</code></pre>
<h3 id="-">클래스와 객체</h3>
<p>클래스란 &#39;객체를 정의해놓은 것&#39; 즉 객체에 대한 설계도나 틀이라고 볼 수 있다.</p>
<p>객체란 사전적인 정의로는 &#39;실제로 존재하는 것&#39;이다. 객체지향이론에서는 사물과 같은 유형적인 것 외에도 개념이나 논리와 같은 무형적인 것들도 객체로 포함한다.</p>
<h3 id="-">객체의 구성요소 - 속성과 기능</h3>
<p>객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다.</p>
<p>이 속성과 기능은 다수로 존재가 가능하다.</p>
<p>이 객체가 가지고 있는 속성과 기능을 &#39;멤버&#39;라고 한다.</p>
<p>주로 속성은 &#39;멤버변수&#39;, 기능은 &#39;메서드&#39;로 표현한다.</p>
<p>ex)</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span> </span>{
    <span class="hljs-comment">// 멤버 변수</span>
    String color;
    <span class="hljs-keyword">boolean</span> power;
    <span class="hljs-keyword">int</span> channel;

    <span class="hljs-comment">// 메서드</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">power</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelUp</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelDown</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<h3 id="-">인스턴스의 생성과 사용</h3>
<p>위에 예시로 든 Tv 클래스의 경우 틀로써 선언이 되었을 뿐 Tv 인스턴스를 생성해야 객체로써 사용할 수 있다.</p>
<pre><code class="lang-java">Tv <span class="hljs-built_in">t</span>; // 클래스 객체를 참조하기 위한 변수 <span class="hljs-built_in">t</span> 선언
<span class="hljs-built_in">t</span> = new Tv(); // 클래스 객체를 생성 후 객체의 주소를 <span class="hljs-built_in">t</span>에 저장
</code></pre>
<p>Tv 타입의 t를 참조변수로 선언한다. 이 때 메모리에 참조변수 t를 위한 공간(Heap)이 마련된다.</p>
<p>new 연산자를 통해 Tv 인스턴스를 생성하면 이 때 멤버변수는 원시형 같은 경우는 기본값으로 참조형 같은 경우 null로 초기화 된다. 이후 대입 연산자에 의한 객체의 주소값이 참조변수 t에 저장된다.</p>
<p>(생성자를 따로 선언한 경우에는 기본값이나 null이 아닌 개발자가 선언한 데로 초기화가 될 것이다.)</p>
<p>이 때 생성된 인스턴스를 통해</p>
<pre><code class="lang-java">t.channel = <span class="hljs-number">7</span><span class="hljs-comment">;</span>
t.power()<span class="hljs-comment">;</span>
</code></pre>
<p>와 같이 인스턴스.멤버변수 혹은 인스턴스.메서드처럼 접근과 초기화가 가능하다.</p>
<p>하지만 이와 같은 방법이 그리 바람직하지 않다.</p>
<p>인스턴스의 멤버변수에 접근하여 다른 값으로 초기화를 할 때 데이터에 대한 유효성이 검증되지 않았고 멤버 변수에 맞지 않는 타입을 대입하여 오류를 발생시킬 수 있기 때문이다.</p>
<p>위에서 말했던 객체지향의 특징 3번째에 해당하는 신뢰성에 대한 부분을 잃게 된다.</p>
<ul>
<li>인스턴스는 참조변수를 통해서만 다룰 수 있으면, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.</li>
</ul>
<ul>
<li><p>같은 클래스로부터 생성되었을 지라도 각 인스턴스의 멤버변수는 서로 고유값을 가지지만 메서드의 내용은 모든 인스턴스에 대해 동일하다.</p>
</li>
<li><p>하나의 인스턴스를 여러 참조 변수가 참조하는 것은 가능하지만 하나의 참조변수가 여러 인스턴스를 참조하는 것은 불가능하다.</p>
</li>
</ul>
<h4 id="-">클래스의 또 다른 정의</h4>
<ol>
<li>클래스 - 데이터와 함수의 결합</li>
</ol>
<p>  데이터 처리를 위한 데이터 저장 형태의 발전 과정은 아래와 같다.</p>
<pre><code><span class="hljs-number">1</span>. 변수 : 하나의 데이터를 저장할 수 있는 공간
<span class="hljs-number">2</span>. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
<span class="hljs-number">3</span>. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
<span class="hljs-number">4</span>. 클래스 : 데이터와 함수의 결합(구조체 + 함수)
</code></pre><p>하나의 데이터를 저장하기 위해 변수를, 그리고 같은 종류의 데이터를 보다 효율적으로 다루기 위해서 배열이라는 개념을 도입했으며, 후에는 구조체(structure)가 등장하여 자료형의 종류와 상관없이 서로 관계가 깊은 변수들을 하나로 묶어서 다루었다.</p>
<p>그 동안 데이터와 함수는 서로 관계가 없는 것처럼 다루었지만 사실 함수도 데이터를 가지고 다루기 때문에 많은 경우에 있어 데이터와 함수는 관계가 깊고 클래스의 형태가 등장했다.</p>
<ol>
<li>클래스 - 사용자 정의 타입</li>
</ol>
<p>원시형 타입 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자 정의 타입이라고 한다.</p>
<p>위의 예시에서 Tv 타입이 사용자 정의 타입이라고 할 수 있다.</p>
<p>하나의 시간에 대한 데이터를 저장할 때 시,분,초를 각각</p>
<pre><code class="lang-java"><span class="hljs-built_in">int</span> <span class="hljs-built_in">hour</span>;
<span class="hljs-built_in">int</span> <span class="hljs-built_in">minute</span>;
<span class="hljs-built_in">int</span> <span class="hljs-built_in">second</span>;
</code></pre>
<p>로 정의한다면 3 개의 시간에 대해 다룰 때는 배열을 이용해 아래와 같이 표현할 수 있을 것이다.</p>
<pre><code class="lang-java"><span class="hljs-built_in">int</span>[] <span class="hljs-built_in">hour</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];
<span class="hljs-built_in">int</span>[] <span class="hljs-built_in">minute</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];
<span class="hljs-built_in">int</span>[] <span class="hljs-built_in">second</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];
</code></pre>
<p>하지만 이와 같은 표현은 어떤 시간이 어떤 분과 또 어떤 초과 대응하는 지 보장을 해줄 수가 없다.</p>
<p>그렇기 때문에 사용자 정의 타입을 통해 시,분,초 변수를 하나로 묶어서 하나의 타입으로 표현해야 한다.</p>
<p>또한 이렇게 클래스로 따로 정의할 경우 위에서 말한 객체지향의 특징 3번째 제어자와 메서드를 이용해 신뢰성이 있는 프로그래밍이 가능하다.</p>
<p>멤버 변수를 private 제어자를 사용하여 내부에서만 변수를 제어 가능하도록 선언하고 setter 메서드를 정의해 메서드 안에 유효성 검증 조건문을 통해 변수의 신뢰성을 얻을 수 있다.</p>
<p>위의 예시와 같은 경우 시,분,초에 대한 숫자의 제약 조건을 넣을 수 있을 것이다.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> class Time {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">hour</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">minute</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">second</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setHour(<span class="hljs-built_in">int</span> h) {
        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span> || h &gt; <span class="hljs-number">23</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">hour</span> = h;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setMinute(<span class="hljs-built_in">int</span> m) {
        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span> || m &gt; <span class="hljs-number">59</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">minute</span> = m;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setSecond(<span class="hljs-built_in">int</span> s) {
        <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span> || s &gt; <span class="hljs-number">59</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">second</span> = s;
    }
}
</code></pre>

  </div>
</body>
</html>